{"ast":null,"code":"import { __decorate, __metadata, __read, __spreadArray, __values } from \"tslib\";\nimport { Component } from \"@angular/core\";\nimport { MatDialog } from \"@angular/material/dialog\";\nimport { ToastrService } from \"ngx-toastr\";\nimport { TacheTicket } from \"src/app/model/tache-ticket\";\nimport { HistoireTicketService } from \"src/app/service/histoire-ticket.service\";\nimport { MembreService } from \"src/app/service/membre.service\";\nimport { RoleService } from \"src/app/service/role.service\";\nimport { SprintBacklogService } from \"src/app/service/sprint-backlog.service\";\nimport { SprintService } from \"src/app/service/sprint.service\";\nimport { TicketTacheService } from \"src/app/service/ticket-tache.service\";\nimport { AjoutTacheSpbComponent } from \"../dialogs/ajout-tache-spb/ajout-tache-spb.component\";\nimport { GestionTacheDialogComponent } from \"../dialogs/gestion-tache-dialog/gestion-tache-dialog.component\";\nimport Swal from \"sweetalert2\";\nimport { WebSocketTicketTacheService } from \"src/app/service/web-socket-ticket-tache.service\";\nvar MapComponent = /** @class */function () {\n  function MapComponent(sprintService, ticketHistoireService, ticketTacheService, sprintBacklogService, membreService, dialogAjout, roleService, toastr, dialogGestion, webSocketService) {\n    var _this = this;\n    this.sprintService = sprintService;\n    this.ticketHistoireService = ticketHistoireService;\n    this.ticketTacheService = ticketTacheService;\n    this.sprintBacklogService = sprintBacklogService;\n    this.membreService = membreService;\n    this.dialogAjout = dialogAjout;\n    this.roleService = roleService;\n    this.toastr = toastr;\n    this.dialogGestion = dialogGestion;\n    this.webSocketService = webSocketService;\n    this.sprintBacklogs = [];\n    this.ticketsTache = [];\n    this.taskMap = new Map();\n    this.listMembre = [];\n    this.showCourbe = false;\n    this.endDate = new Date('2023-03-31T23:59:59');\n    this.activeIndex = -1;\n    this.webSocketService.messageHandlingAdd(new TacheTicket()).subscribe(function (message) {\n      var e_1, _a;\n      console.log(message);\n      if (_this.webSocketService.ticketTache) _this.taskMap.get(message.subscribe.ht).push(_this.webSocketService.ticketTache);\n      if (message.subscribe) {\n        var ticketHistoire = message.subscribe.ht;\n        var _loop_1 = function (key) {\n          if (key.id === ticketHistoire.id) {\n            var listeTache = _this.taskMap.get(key);\n            var productBacklog = JSON.parse(localStorage.getItem('productBacklogCourant'));\n            console.log(message.subscribe); // afficher le message reçu dans la console\n            var ticketTache_1 = message.subscribe;\n            if (!listeTache.find(function (tache) {\n              return tache.id == ticketTache_1.id;\n            }) && ticketTache_1.ht.productBacklogId == productBacklog.id) {\n              listeTache.push(ticketTache_1);\n            }\n          }\n        };\n        try {\n          for (var _b = __values(_this.taskMap.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var key = _c.value;\n            _loop_1(key);\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      }\n    });\n    this.webSocketService.messageHandlingSupprimer(new TacheTicket()).subscribe(function (message) {\n      var e_2, _a;\n      if (message.supprimer) {\n        var ticketTache_2 = message.supprimer;\n        var ticketHistoire = message.supprimer.ht;\n        try {\n          for (var _b = __values(_this.taskMap.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var key = _c.value;\n            if (key.id === ticketHistoire.id) {\n              var listeTache = _this.taskMap.get(key);\n              if (listeTache.find(function (tache) {\n                return tache.id == ticketTache_2.id;\n              })) {\n                listeTache.splice(listeTache.indexOf(listeTache.find(function (tache) {\n                  return tache.id == ticketTache_2.id;\n                })), 1);\n              }\n            }\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n      }\n    });\n    this.webSocketService.messageHandlingModifier(new TacheTicket()).subscribe(function (message) {\n      var e_3, _a;\n      if (message.modifier) {\n        var _loop_2 = function (key) {\n          if (key.id === message.modifier.ht.id) {\n            var listeTache = _this.taskMap.get(key);\n            var ticketTache_3 = message.modifier;\n            if (listeTache.find(function (tache) {\n              return tache.id == ticketTache_3.id;\n            })) {\n              console.log(ticketTache_3.titre);\n              listeTache[listeTache.indexOf(listeTache.find(function (tache) {\n                return tache.id == ticketTache_3.id;\n              }))] = ticketTache_3;\n            }\n          }\n        };\n        try {\n          for (var _b = __values(_this.taskMap.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var key = _c.value;\n            _loop_2(key);\n          }\n        } catch (e_3_1) {\n          e_3 = {\n            error: e_3_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_3) throw e_3.error;\n          }\n        }\n      }\n    });\n  }\n  MapComponent.prototype.ngOnInit = function () {\n    var _this = this;\n    var projet = JSON.parse(localStorage.getItem('projet'));\n    this.roleService.afficherListRoleParProjet(projet.id).subscribe(function (data) {\n      var e_4, _a;\n      console.log(data);\n      _this.roles = data;\n      try {\n        for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {\n          var role = data_1_1.value;\n          _this.listMembre.push(role.membre);\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n    });\n    var productBacklog = JSON.parse(localStorage.getItem('productBacklogCourant'));\n    this.sprintService.getListSprintsByProductBacklog(productBacklog.id).subscribe(function (listSprintData) {\n      listSprintData = listSprintData.filter(function (sprint) {\n        return sprint.etat != \"en attente\";\n      });\n      _this.sprintsList = listSprintData;\n      for (var i = 0; i < listSprintData.length; i++) _this.sprintBacklogService.afficherSprintBacklogBySprintId(listSprintData[i].id).subscribe(function (sprintBacklogData) {\n        _this.sprintBacklogs.push(sprintBacklogData);\n      });\n    });\n  };\n  MapComponent.prototype.afficherDetailSprintBacklog = function (sprintBacklog) {\n    var _this = this;\n    console.log(sprintBacklog.sprint.id);\n    var taskMap = new Map();\n    this.ticketHistoireService.getHistoireTicketBySprintId(sprintBacklog.sprint.id).subscribe(function (data) {\n      var e_5, _a;\n      _this.ticketsHistoireList = data;\n      var _loop_3 = function (ht) {\n        _this.ticketTacheService.getListTicketTacheParHt(ht.id).subscribe(function (listTacheData) {\n          _this.ticketsTache = listTacheData;\n          taskMap.set(ht, _this.ticketsTache);\n          console.log(_this.ticketsTache);\n        });\n      };\n      try {\n        for (var _b = __values(_this.ticketsHistoireList), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var ht = _c.value;\n          _loop_3(ht);\n        }\n      } catch (e_5_1) {\n        e_5 = {\n          error: e_5_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_5) throw e_5.error;\n        }\n      }\n      _this.taskMap = taskMap;\n    });\n  };\n  //choix couleur tache\n  MapComponent.prototype.getBackgroundColor = function (index) {\n    if (index % 2 === 0) {\n      return {\n        'background-color': '#C8F8F3'\n      };\n    } else if (index % 3 == 0 && index % 2 == 0) {\n      return {\n        'background-color': '#F0FCCA'\n      };\n    } else if (index % 3 == 0) {\n      return {\n        'background-color': '#EFF8C2'\n      };\n    } else if (index % 7 == 0) {\n      return {\n        'background-color': '#F8E7C2'\n      };\n    } else if (index == 1) {\n      return {\n        'background-color': '#DDDAD3'\n      };\n    } else {\n      return {};\n    }\n  };\n  MapComponent.prototype.prendreTicket = function (idTicketTache, ht) {\n    var _this = this;\n    var ticket = this.taskMap.get(ht).find(function (tache) {\n      return tache.id == idTicketTache;\n    });\n    Swal.fire({\n      title: \"vous êtes sûr de prendre la tâche : \" + (ticket === null || ticket === void 0 ? void 0 : ticket.titre),\n      icon: 'warning',\n      showCancelButton: true,\n      confirmButtonColor: '#3085d6',\n      cancelButtonColor: '#d33',\n      confirmButtonText: 'Oui, Lancer!',\n      cancelButtonText: 'Annuler',\n      background: 'rgba(0,0,0,0.9)',\n      backdrop: 'rgba(0,0,0,0.4)',\n      allowOutsideClick: false,\n      allowEscapeKey: false,\n      allowEnterKey: false,\n      focusConfirm: false\n    }).then(function (result) {\n      if (result.isConfirmed) {\n        var membre = _this.membreService.getMembreFromToken();\n        _this.ticketTacheService.affecterTicketAMembre(membre, idTicketTache).subscribe(function (dataTicket) {\n          _this.ticketsTache.forEach(function (ticket) {\n            if (ticket.id == idTicketTache) {\n              ticket.dateFin = dataTicket.ht.dateFin;\n              ticket.dateLancement = dataTicket.dateLancement;\n              ticket.membre = dataTicket.membre;\n              ticket.membreId = dataTicket.membreId;\n              Swal.fire('tâche pris', 'Vous êtes le responsable de cette tâche vieulliez à ce quelle soit terminé dans ' + ticket.nbHeurs + \"H\", 'success');\n              _this.webSocketService.messageHandlingModifier(ticket).subscribe(function (message) {\n                console.log(message.modifier); // afficher le message reçu dans la console\n              }, function (err) {\n                console.error(err); // afficher les erreurs dans la console\n              }, function () {\n                console.log('WebSocket connection closed'); // afficher un message lorsque la connexion est fermée\n              });\n            }\n          });\n        });\n      }\n    });\n  };\n\n  MapComponent.prototype.reverseIndex = function (index, length) {\n    return length - index;\n  };\n  MapComponent.prototype.toggleAccordion = function (index) {\n    if (index === this.activeIndex) {\n      this.sprintBacklogs[index].isOpen = false;\n      this.activeIndex = -1;\n    } else {\n      this.sprintBacklogs.forEach(function (item, i) {\n        item.isOpen = i === index ? true : false;\n      });\n      this.activeIndex = index;\n    }\n  };\n  MapComponent.prototype.openAjoutDialog = function (ht, sprintBacklog) {\n    var _this = this;\n    var dialogRef = this.dialogAjout.open(AjoutTacheSpbComponent, {\n      width: '350px',\n      height: '550px',\n      data: {\n        sprintBacklog: sprintBacklog,\n        ticketHistoire: ht\n      }\n    });\n    dialogRef.afterClosed().subscribe(function (result) {\n      var e_6, _a;\n      if (result) {\n        var ticketHistoire_1 = result.ht;\n        try {\n          for (var _b = __values(_this.taskMap.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var key = _c.value;\n            if (key.id === ticketHistoire_1.id) {\n              var listeTache = _this.taskMap.get(key);\n              listeTache.push(result);\n              result.ht.sprintId = result.sprintBacklog.sprintId;\n              result.ht.status = \"EN_COURS\";\n              _this.webSocketService.messageHandlingAdd(result).subscribe(function (message) {}, function (err) {\n                console.error(err); // afficher les erreurs dans la console\n              }, function () {\n                console.log('WebSocket connection closed'); // afficher un message lorsque la connexion est fermée\n              });\n\n              console.log(result);\n              result.ht.sprintId = result.sprintBacklog.sprintId;\n              result.ht.status = \"EN_COURS\";\n              _this.ticketHistoireService.updateUserStory(result.ht.id, result.ht).subscribe(function (dataHistoire) {\n                console.log(dataHistoire);\n                // key.status = \"EN_COURS\"\n                // Récupérer la date la plus récente de la liste des tâches associées à un ticket d'histoire\n                _this.ticketTacheService.getListTicketTacheParHt(ticketHistoire_1.id).subscribe(function (tacheTickets) {\n                  var timestamps = tacheTickets.map(function (t) {\n                    return new Date(t.dateFin).getTime();\n                  });\n                  var maxTimestamp = Math.max.apply(Math, __spreadArray([], __read(timestamps), false));\n                  var datePlusRecente = new Date(maxTimestamp);\n                  // Mettre à jour la date de result.ht avec la date la plus récente\n                  result.ht.dateFin = datePlusRecente.toISOString(); // Convertir la date en format ISO\n                  // Mettre à jour l'histoire utilisateur avec la nouvelle date de fin\n                  _this.ticketHistoireService.updateUserStory(result.ht.id, result.ht).subscribe(function (dataHistoire) {\n                    console.log(dataHistoire);\n                    // key.status = \"EN_COURS\"\n                  });\n                });\n              });\n            }\n          }\n        } catch (e_6_1) {\n          e_6 = {\n            error: e_6_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_6) throw e_6.error;\n          }\n        }\n      }\n    });\n  };\n  MapComponent.prototype.openGestionTache = function (tt) {\n    var _this = this;\n    var dialogRef = this.dialogGestion.open(GestionTacheDialogComponent, {\n      width: '650px',\n      height: '300px',\n      data: {\n        ticketTache: tt\n      }\n    });\n    dialogRef.afterClosed().subscribe(function (result) {\n      var e_7, _a, e_8, _b;\n      console.log(result);\n      if (result.mode == 'modifier') {\n        _this.webSocketService.messageHandlingModifier(result.tt).subscribe(function (message) {\n          console.log(message.modifier); // afficher le message reçu dans la console\n        }, function (err) {\n          console.error(err); // afficher les erreurs dans la console\n        }, function () {\n          console.log('WebSocket connection closed'); // afficher un message lorsque la connexion est fermée\n        });\n      } else if (result.mode == 'supprimer') {\n        var ticketHistoire = result.tt.ht;\n        try {\n          for (var _c = __values(_this.taskMap.keys()), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var key = _d.value;\n            if (key.id === ticketHistoire.id) {\n              var listeTache = _this.taskMap.get(key);\n              _this.webSocketService.messageHandlingSupprimer(result.tt).subscribe(function (message) {\n                console.log(message.supprimer); // afficher le message reçu dans la console\n              }, function (err) {\n                console.error(err); // afficher les erreurs dans la console\n              }, function () {\n                console.log('WebSocket connection closed'); // afficher un message lorsque la connexion est fermée\n              });\n            }\n          }\n        } catch (e_7_1) {\n          e_7 = {\n            error: e_7_1\n          };\n        } finally {\n          try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n          } finally {\n            if (e_7) throw e_7.error;\n          }\n        }\n      } else if (result.mode == 'terminer') {\n        var ticketHistoire = result.tt.ht;\n        try {\n          for (var _e = __values(_this.taskMap.keys()), _f = _e.next(); !_f.done; _f = _e.next()) {\n            var key = _f.value;\n            if (key.id === ticketHistoire.id) {\n              var listeTache = _this.taskMap.get(key);\n              var listeTacheTermine = listeTache.filter(function (tache) {\n                return tache.etat == \"terminé\";\n              });\n              if (listeTacheTermine.length == listeTache.length) {\n                ticketHistoire.status = \"TERMINE\";\n                console.log(ticketHistoire);\n                var listeTacheTermineDates = listeTacheTermine.map(function (tache) {\n                  return new Date(tache.dateFin).getTime();\n                });\n                var maxDateFin = new Date(Math.max.apply(Math, __spreadArray([], __read(listeTacheTermineDates), false)));\n                ticketHistoire.dateFin = maxDateFin;\n                _this.ticketHistoireService.updateUserStory(ticketHistoire.id, ticketHistoire).subscribe(function (dataHistoire) {\n                  console.log(dataHistoire);\n                  if (!_this.verifSprintBacklogTerminer()) Swal.fire('Félicitation ', 'vous avez terminer un histoire de sprint', 'success');else Swal.fire('Félicitation ', 'vous avez terminer le sprint ,\\n avez vous respecter le time Box', 'success');\n                });\n              }\n            }\n          }\n        } catch (e_8_1) {\n          e_8 = {\n            error: e_8_1\n          };\n        } finally {\n          try {\n            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n          } finally {\n            if (e_8) throw e_8.error;\n          }\n        }\n      }\n    });\n  };\n  MapComponent.prototype.checkRole = function (membre) {\n    var role = this.roles.find(function (role) {\n      return role.membre.id === membre.id;\n    });\n    return role.status == \"ACCEPTE\";\n  };\n  MapComponent.prototype.verifierPersPris = function (membre) {\n    var prendre = \"cette ticket est pris par \";\n    if (this.membreService.getMembreFromToken().id == membre.id) this.toastr.success(\"\".concat(prendre, \" Vous \\t\\uD83D\\uDE00\"));else this.toastr.success(\"\".concat(prendre, \" \").concat(membre.email));\n  };\n  MapComponent.prototype.verifSprintBacklogTerminer = function () {\n    var e_9, _a;\n    try {\n      for (var _b = __values(this.taskMap.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var key = _c.value;\n        if (key.status == \"EN_COURS\") return false;\n      }\n    } catch (e_9_1) {\n      e_9 = {\n        error: e_9_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_9) throw e_9.error;\n      }\n    }\n    return true;\n  };\n  MapComponent.prototype.detacherMembreDeTache = function (tache) {\n    var _this = this;\n    if (tache.etat != \"terminé\") {\n      console.log(tache);\n      Swal.fire({\n        title: \"vous êtes sûr de vous détacher de cette tâche ?\",\n        icon: 'info',\n        showCancelButton: true,\n        confirmButtonColor: '#3085d6',\n        cancelButtonColor: '#d33',\n        confirmButtonText: 'Oui !',\n        cancelButtonText: 'Annuler',\n        backdrop: 'rgba(0,0,0,0.4)',\n        allowOutsideClick: false,\n        allowEscapeKey: false,\n        allowEnterKey: false,\n        focusConfirm: false\n      }).then(function (result) {\n        if (result.isConfirmed) {\n          tache.dateFin = null;\n          tache.dateLancement = null;\n          tache.membreId = null;\n          tache.membre = null;\n          _this.ticketTacheService.modifierTicketTache(tache).subscribe(function (data) {\n            tache = data;\n            _this.webSocketService.messageHandlingModifier(data).subscribe(function (message) {\n              console.log(message.modifier); // afficher le message reçu dans la console\n            }, function (err) {\n              console.error(err); // afficher les erreurs dans la console\n            }, function () {\n              console.log('WebSocket connection closed'); // afficher un message lorsque la connexion est fermée\n            });\n          });\n        }\n      });\n    } else {\n      Swal.fire('attentient', 'cette tâche est terminé', 'warning');\n    }\n  };\n  MapComponent = __decorate([Component({\n    selector: \"app-map\",\n    templateUrl: \"map.component.html\",\n    styleUrls: ['./map.component.scss']\n  }), __metadata(\"design:paramtypes\", [SprintService, HistoireTicketService, TicketTacheService, SprintBacklogService, MembreService, MatDialog, RoleService, ToastrService, MatDialog, WebSocketTicketTacheService])], MapComponent);\n  return MapComponent;\n}();\nexport { MapComponent };\n// import { Component, Directive, OnInit } from \"@angular/core\";\n// import { MatDialog } from \"@angular/material/dialog\";\n// import { ToastrService } from \"ngx-toastr\";\n// import { Membre } from \"src/app/model/membre\";\n// import { Projet } from \"src/app/model/projet\";\n// import { Role } from \"src/app/model/role\";\n// import { Sprint } from \"src/app/model/sprint\";\n// import { SprintBacklog } from \"src/app/model/sprint-backlog\";\n// import { TacheTicket } from \"src/app/model/tache-ticket\";\n// import { TicketHistoire } from \"src/app/model/ticket-histoire\";\n// import { HistoireTicketService } from \"src/app/service/histoire-ticket.service\";\n// import { MembreService } from \"src/app/service/membre.service\";\n// import { RoleService } from \"src/app/service/role.service\";\n// import { SprintBacklogService } from \"src/app/service/sprint-backlog.service\";\n// import { SprintService } from \"src/app/service/sprint.service\";\n// import { TicketTacheService } from \"src/app/service/ticket-tache.service\";\n// import { AjoutTacheSpbComponent } from \"../dialogs/ajout-tache-spb/ajout-tache-spb.component\";\n// import { GestionTacheDialogComponent } from \"../dialogs/gestion-tache-dialog/gestion-tache-dialog.component\";\n// import Swal from \"sweetalert2\";\n// export interface DialogDataTicketTache {\n//   sprintBacklog: SprintBacklog;\n//   ticketHistoire:TicketHistoire\n// }\n// export interface DialogGererDataTicketTache {\n//   ticketTache:TacheTicket\n// }\n// @Component({\n//   selector: \"app-map\",\n//   templateUrl: \"map.component.html\",\n//   styleUrls: ['./map.component.scss'],\n// })\n// export class MapComponent implements OnInit {\n//   constructor(\n//     private sprintService:SprintService,\n//     private ticketHistoireService:HistoireTicketService,\n//     private ticketTacheService:TicketTacheService,\n//     private sprintBacklogService:SprintBacklogService,\n//     private membreService:MembreService,\n//     private dialogAjout: MatDialog,\n//     private roleService:RoleService,\n//     private toastr: ToastrService,\n//     private dialogGestion:MatDialog\n//   ) {}\n//   sprintsList:Sprint[]\n//   sprintBacklogs:SprintBacklog[]=[]\n//   ticketsHistoireList:TicketHistoire[]\n//   ticketsTache:TacheTicket[]=[]\n//   taskMap:Map<TicketHistoire,TacheTicket[]>=new Map<TicketHistoire,TacheTicket[]>()\n//   listMembre:Membre[]=[]\n//   showCourbe=false;\n//   ticketTachePrise:TacheTicket[]\n//   endDate: Date = new Date('2023-03-31T23:59:59');\n//   roles:Role[];\n//   dateFin:Date;\n//   ngOnInit() {\n//     const projet:Projet = JSON.parse(localStorage.getItem('projet'))\n//     this.roleService.afficherListRoleParProjet(projet.id).subscribe(\n//       data =>{\n//         console.log(data);\n//         this.roles = data\n//         for(let role of data){\n//           this.listMembre.push(role.membre)\n//         }\n//       }\n//     )\n//     const productBacklog  = JSON.parse(localStorage.getItem('productBacklogCourant'))\n//     this.sprintService.getListSprintsByProductBacklog(productBacklog.id).subscribe(\n//       listSprintData => {\n//           // console.log(listSprintData);\n//           listSprintData = listSprintData.filter(sprint => sprint.etat!=\"en attente\")\n//           this.sprintsList = listSprintData\n//           for(let i = 0; i<listSprintData.length;i++)\n//             this.sprintBacklogService.afficherSprintBacklogBySprintId(listSprintData[i].id).subscribe(\n//               sprintBacklogData =>{\n//                 // console.log(sprintBacklogData);\n//                 this.sprintBacklogs.push(sprintBacklogData);\n//               }\n//             )\n//       }\n//     );\n//   }\n//   afficherDetailSprintBacklog(sprintBacklog:SprintBacklog){\n//       console.log(sprintBacklog.sprint.id);\n//       const taskMap = new Map();\n//       this.ticketHistoireService.getHistoireTicketBySprintId(sprintBacklog.sprint.id).subscribe(\n//         data => {\n//           this.ticketsHistoireList = data;\n//           for(let ht of this.ticketsHistoireList){\n//             this.ticketTacheService.getListTicketTacheParHt(ht.id).subscribe(\n//               listTacheData =>{\n//                 this.ticketsTache = listTacheData;\n//                 taskMap.set(ht,this.ticketsTache)\n//               }\n//             )\n//           }\n//           // for(let ht of this.ticketsHistoireList){\n//           //   this.ticketTacheService.getListTicketTacheParHt(ht.id).subscribe(\n//           //     listTacheData =>{\n//           //       this.ticketsTache = listTacheData;\n//           //       taskMap.set(ht,this.ticketsTache)\n//           //       console.log(this.ticketsTache);\n//           //       // Vérifie si tous les tickets de tâche ont l'état \"terminé\"\n//           //       const allTasksCompleted = this.ticketsTache.every(task => task.etat === \"terminé\");\n//           //       // Si tous les tickets de tâche sont terminés, mettez à jour la date de fin du ticket d'histoire\n//           //       if (allTasksCompleted) {\n//           //         const latestTaskEndDate = Math.max(...this.ticketsTache.map(task => new Date(task.dateFin).getTime()));\n//           //         ht.dateFin = new Date(latestTaskEndDate);\n//           //         this.ticketHistoireService.updateUserStory(ht.id, ht).subscribe(updatedHistoireTicket => {\n//           //           console.log(\"Ticket d'histoire mis à jour : \", updatedHistoireTicket);\n//           //         });\n//           //       }else{\n//           //         this.ticketsTache = listTacheData;\n//           //         taskMap.set(ht,this.ticketsTache)\n//           //       }\n//           //     }\n//           //   )\n//           // }\n//           this.taskMap = taskMap\n//         }\n//       )\n//   }\n//   //choix couleur tache\n//   getBackgroundColor(index: number): any {\n//     if (index % 2 === 0) {\n//       return { 'background-color': '#C8F8F3' };\n//     } else if (index % 3 == 0 && index % 2 == 0) {\n//       return { 'background-color': '#F0FCCA' };\n//     } else if (index % 3 == 0) {\n//       return { 'background-color': '#EFF8C2' };\n//     } else if (index % 7 == 0) {\n//       return { 'background-color': '#F8E7C2' };\n//     }else if (index == 1) {\n//       return { 'background-color': '#DDDAD3' };\n//     } else {\n//       return {};\n//     }\n//   }\n//   prendreTicket(idTicketTache:number){\n//     const  ticket = this.ticketsTache.find(tache=>tache.id == idTicketTache)\n//     Swal.fire({\n//       title: \"vous êtes sûr de prendre la tâche : \"+ticket?.titre,\n//       icon: 'warning',\n//       showCancelButton: true,\n//       confirmButtonColor: '#3085d6',\n//       cancelButtonColor: '#d33',\n//       confirmButtonText: 'Oui, Lancer!',\n//       cancelButtonText: 'Annuler',\n//       background:'rgba(0,0,0,0.9)',\n//       backdrop: 'rgba(0,0,0,0.4)',\n//       allowOutsideClick: false,\n//       allowEscapeKey: false,\n//       allowEnterKey: false,\n//       focusConfirm: false\n//     }).then((result) => {\n//       if (result.isConfirmed) {\n//         const membre = JSON.parse(localStorage.getItem('membre'))\n//         this.ticketTacheService.affecterTicketAMembre(membre,idTicketTache).subscribe(\n//         dataTicket=>{\n//             this.ticketsTache.forEach(ticket=>{\n//               if(ticket.id == idTicketTache){\n//                 ticket.dateFin = dataTicket.ht.dateFin\n//                 ticket.dateLancement = dataTicket.dateLancement\n//                 ticket.membre = dataTicket.membre\n//                 ticket.membreId = dataTicket.membreId\n//                 Swal.fire(\n//                   'tâche pris',\n//                   'Vous êtes le responsable de cette tâche vieulliez à ce quelle soit terminé dans '+ticket.nbHeurs+\"H\",\n//                   'success'\n//                 )\n//               }\n//             })\n//         }\n//       )\n//       }\n//      }\n//     );\n//   }\n//   reverseIndex(index: number, length: number): number {\n//     return length - index;\n//   }\n//   activeIndex = -1;\n//   toggleAccordion(index: number) {\n//     if (index === this.activeIndex) {\n//       this.sprintBacklogs[index].isOpen = false;\n//       this.activeIndex = -1;\n//     } else {\n//       this.sprintBacklogs.forEach((item, i) => {\n//         item.isOpen = i === index ? true : false;\n//       });\n//       this.activeIndex = index;\n//     }\n//   }\n//   // openAjoutDialog(ht:TicketHistoire,sprintBacklog:SprintBacklog){\n//   //   const dialogRef = this.dialogAjout.open(AjoutTacheSpbComponent,{\n//   //     width: '350px',\n//   //     height:'550px',\n//   //     data: {sprintBacklog:sprintBacklog,\n//   //            ticketHistoire:ht\n//   //     }\n//   //   });\n//   //   dialogRef.afterClosed().subscribe(result => {\n//   //     if(result){\n//   //     const ticketHistoire = result.ht\n//   //     for(const key of this.taskMap.keys()) {\n//   //       if (key.id === ticketHistoire.id) {\n//   //         const listeTache = this.taskMap.get(key)\n//   //         listeTache.push(result)\n//   //         console.log(result);\n//   //         result.ht.sprintId = result.sprintBacklog.sprintId\n//   //         result.ht.status = \"EN_COURS\"\n//   //         this.ticketHistoireService.updateUserStory(result.ht.id,result.ht).subscribe(\n//   //           dataHistoire =>{\n//   //             console.log(dataHistoire)\n//   //             key.status = \"EN_COURS\"\n//   //           }\n//   //         )\n//   //       }\n//   //      }\n//   //    }\n//   //   });\n//   // }\n//   openAjoutDialog(ht:TicketHistoire,sprintBacklog:SprintBacklog){\n//     const dialogRef = this.dialogAjout.open(AjoutTacheSpbComponent,{\n//       width: '350px',\n//       height:'550px',\n//       data: {sprintBacklog:sprintBacklog,\n//              ticketHistoire:ht\n//       }\n//     });\n// dialogRef.afterClosed().subscribe(result => {\n//   if(result){\n//     const ticketHistoire = result.ht\n//     for(const key of this.taskMap.keys()) {\n//       if (key.id === ticketHistoire.id) {\n//         const listeTache = this.taskMap.get(key)\n//         listeTache.push(result)\n//         console.log(result);\n//         result.ht.sprintId = result.sprintBacklog.sprintId\n//         result.ht.status = \"EN_COURS\"\n//         this.ticketHistoireService.updateUserStory(result.ht.id,result.ht).subscribe(\n//           dataHistoire =>{\n//             console.log(dataHistoire)\n//             // key.status = \"EN_COURS\"\n//             // Récupérer la date la plus récente de la liste des tâches associées à un ticket d'histoire\n//             this.ticketTacheService.getListTicketTacheParHt(ticketHistoire.id).subscribe(\n//               tacheTickets => {\n//                 const timestamps = tacheTickets.map(t => new Date(t.dateFin).getTime());\n//                 const maxTimestamp = Math.max(...timestamps);\n//                 const datePlusRecente = new Date(maxTimestamp);\n//                 // Mettre à jour la date de result.ht avec la date la plus récente\n//                 result.ht.dateFin = datePlusRecente.toISOString(); // Convertir la date en format ISO\n//                 // Mettre à jour l'histoire utilisateur avec la nouvelle date de fin\n//                 this.ticketHistoireService.updateUserStory(result.ht.id,result.ht).subscribe(\n//                   dataHistoire =>{\n//                     console.log(dataHistoire)\n//                     // key.status = \"EN_COURS\"\n//                   }\n//                 )\n//               }\n//             );\n//           }\n//         )\n//       }\n//     }\n//   }\n// });\n//   }\n//   openGestionTache(tt:TacheTicket){\n//     const dialogRef = this.dialogGestion.open(GestionTacheDialogComponent,{\n//       width: '650px',\n//       height:'300px',\n//       data: {\n//         ticketTache:tt\n//       }\n//     });\n//     dialogRef.afterClosed().subscribe(result => {\n//       console.log(result);\n//       if(result.mode == 'modifier'){\n//         console.log(\"test\");\n//           for(const key of this.taskMap.keys()) {\n//             if (key.id === result.tt.ht.id) {\n//               const listeTache = this.taskMap.get(key)\n//               listeTache[listeTache.indexOf(tt)]=result.tt\n//             }\n//           }\n//       }\n//       else if(result.mode == 'supprimer'){\n//       const ticketHistoire = result.tt.ht\n//       for(const key of this.taskMap.keys()) {\n//         if (key.id === ticketHistoire.id) {\n//           const listeTache = this.taskMap.get(key)\n//           console.log(listeTache.indexOf(tt));\n//           listeTache.splice(listeTache.indexOf(tt),1)\n//         }\n//        }}\n//     //  }else if(result.mode == 'terminer'){\n//     //   const ticketHistoire = result.tt.ht\n//     //   for(const key of this.taskMap.keys()) {\n//     //     if (key.id === ticketHistoire.id) {\n//     //       const listeTache = this.taskMap.get(key)\n//     //       const listeTacheTermine = listeTache.filter(tache => tache.etat == \"terminé\")\n//     //       if(listeTacheTermine.length == listeTache.length){\n//     //         ticketHistoire.status = \"TERMINE\"\n//     //         console.log(ticketHistoire);\n//     //         this.ticketHistoireService.updateUserStory(ticketHistoire.id,ticketHistoire).subscribe(\n//     //           dataHistoire =>{\n//     //             console.log(dataHistoire)\n//     //             Swal.fire(\n//     //               'Félicitation ',\n//     //               'vous avez terminer un histoire de sprint',\n//     //               'success'\n//     //             )\n//     //           }\n//     //         )\n//     //       }\n//     //     }\n//     //   }\n//     //  }\n//     else if(result.mode == 'terminer'){\n//       const ticketHistoire = result.tt.ht\n//       for(const key of this.taskMap.keys()) {\n//         if (key.id === ticketHistoire.id) {\n//           const listeTache = this.taskMap.get(key)\n//           const listeTacheTermine = listeTache.filter(tache => tache.etat == \"terminé\")\n//           if(listeTacheTermine.length == listeTache.length){\n//             ticketHistoire.status = \"TERMINE\"\n//             const listeTacheTermineDates = listeTacheTermine.map(tache => new Date(tache.dateFin).getTime());\n//             const maxDateFin = new Date(Math.max(...listeTacheTermineDates));\n//             ticketHistoire.dateFin = maxDateFin;\n//             console.log(ticketHistoire);\n//             this.ticketHistoireService.updateUserStory(ticketHistoire.id,ticketHistoire).subscribe(\n//               dataHistoire =>{\n//                 console.log(dataHistoire)\n//                 Swal.fire(\n//                   'Félicitation ',\n//                   'vous avez terminer un histoire de sprint',\n//                   'success'\n//                 )\n//               }\n//             )\n//           }\n//         }\n//       }\n//      }\n//     });\n//   }\n//   checkRole(membre:Membre){\n//     const role = this.roles.find(role => role.membre.id === membre.id);\n//     return role.status == \"ACCEPTE\"\n//   }\n//   verifierPersPris(membre:Membre){\n//     const prendre = \"cette ticket est pris par \"\n//     if(JSON.parse(localStorage.getItem('membre')).id == membre.id)\n//       this.toastr.success(`${prendre} Vous \t😀`);\n//     else\n//       this.toastr.success(`${prendre} ${membre.email}`);\n//   }\n// }","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}